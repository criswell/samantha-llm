#!/usr/bin/env python3
"""
samantha-llm - Installation and management script for Samantha Hartwell LLM

Cross-platform installer supporting Linux, macOS, and Windows.
Version: 0.2.0
"""

import argparse
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from datetime import datetime


# Version
VERSION = "0.2.0"

# ANSI color codes
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

    @classmethod
    def supports_color(cls):
        """Check if terminal supports color"""
        if platform.system() == 'Windows':
            # Windows 10+ supports ANSI colors with VT100 emulation
            return True
        return hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()


def print_info(message):
    """Print info message"""
    if Colors.supports_color():
        print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}")
    else:
        print(f"[INFO] {message}")


def print_success(message):
    """Print success message"""
    if Colors.supports_color():
        print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}")
    else:
        print(f"[SUCCESS] {message}")


def print_warning(message):
    """Print warning message"""
    if Colors.supports_color():
        print(f"{Colors.YELLOW}[WARNING]{Colors.NC} {message}")
    else:
        print(f"[WARNING] {message}")


def print_error(message):
    """Print error message"""
    if Colors.supports_color():
        print(f"{Colors.RED}[ERROR]{Colors.NC} {message}")
    else:
        print(f"[ERROR] {message}")


def get_platform():
    """Get platform name (linux, darwin, windows)"""
    return platform.system().lower()


def get_install_dir():
    """Get platform-appropriate install directory"""
    system = get_platform()
    if system == 'windows':
        return Path(os.environ['LOCALAPPDATA']) / 'Programs' / 'samantha-llm'
    else:  # Linux, Darwin (macOS)
        return Path.home() / '.local' / 'bin'


def get_config_dir():
    """Get platform-appropriate config directory"""
    system = get_platform()
    if system == 'windows':
        return Path(os.environ['APPDATA']) / 'samantha-llm'
    else:  # Linux, Darwin (macOS)
        return Path.home() / '.config' / 'samantha-llm'


def get_script_name():
    """Get platform-appropriate script name"""
    system = get_platform()
    if system == 'windows':
        return 'samantha-llm.bat'
    else:
        return 'samantha-llm'


def get_repo_dir():
    """Get the samantha-llm repository directory"""
    # This script should be in the root of the repo
    return Path(__file__).resolve().parent


def get_config_file():
    """Get config file path"""
    return get_config_dir() / 'config'


def get_install_path():
    """Get full install path"""
    return get_install_dir() / get_script_name()


def is_installed():
    """Check if samantha-llm is installed"""
    install_path = get_install_path()
    config_file = get_config_file()

    system = get_platform()
    if system == 'windows':
        # On Windows, check if .bat file exists and config exists
        return install_path.exists() and config_file.exists()
    else:
        # On Unix, check if symlink exists and config exists
        return install_path.is_symlink() and config_file.exists()


def check_path():
    """Check if install directory is in PATH"""
    install_dir = str(get_install_dir())
    path_env = os.environ.get('PATH', '')

    if platform.system() == 'Windows':
        # Windows is case-insensitive and uses ; as separator
        paths = [p.lower() for p in path_env.split(';')]
        return install_dir.lower() in paths
    else:
        # Unix uses : as separator
        return install_dir in path_env.split(':')


def create_config():
    """Create config file"""
    config_dir = get_config_dir()
    config_file = get_config_file()
    repo_dir = get_repo_dir()

    # Create config directory
    config_dir.mkdir(parents=True, exist_ok=True)

    # Write config file
    print_info(f"Creating config file: {config_file}")
    config_content = f"""# Samantha Hartwell LLM Configuration
# Auto-generated on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

# Path to the samantha-llm repository
SAMANTHA_REPO_PATH="{repo_dir}"

# Version
SAMANTHA_VERSION="{VERSION}"

# Platform
SAMANTHA_PLATFORM="{get_platform()}"
"""
    config_file.write_text(config_content)


def install_unix():
    """Install on Unix-like systems (Linux, macOS) using symlink"""
    install_dir = get_install_dir()
    install_path = get_install_path()
    repo_dir = get_repo_dir()
    source_script = repo_dir / 'samantha-llm.py'

    # Create install directory
    if not install_dir.exists():
        print_info(f"Creating install directory: {install_dir}")
        install_dir.mkdir(parents=True, exist_ok=True)

    # Remove existing symlink if present
    if install_path.exists() or install_path.is_symlink():
        print_info("Removing existing symlink...")
        install_path.unlink()

    # Create symlink
    print_info(f"Creating symlink: {install_path} -> {source_script}")
    install_path.symlink_to(source_script)

    # Make source script executable
    source_script.chmod(source_script.stat().st_mode | 0o111)


def install_windows():
    """Install on Windows by copying script and creating batch wrapper"""
    install_dir = get_install_dir()
    install_path = get_install_path()
    repo_dir = get_repo_dir()
    source_script = repo_dir / 'samantha-llm.py'

    # Create install directory
    if not install_dir.exists():
        print_info(f"Creating install directory: {install_dir}")
        install_dir.mkdir(parents=True, exist_ok=True)

    # Copy Python script
    script_target = install_dir / 'samantha-llm.py'
    print_info(f"Copying script: {source_script} -> {script_target}")
    shutil.copy2(source_script, script_target)

    # Create batch wrapper
    print_info(f"Creating batch wrapper: {install_path}")
    wrapper_content = f'@echo off\npython "{script_target}" %*\n'
    install_path.write_text(wrapper_content)

    # Add to PATH
    if not check_path():
        print_info("Adding install directory to PATH...")
        if add_to_windows_path(install_dir):
            print_success("Added to PATH successfully")
            print_warning("Please restart your terminal/PowerShell for PATH changes to take effect")
        else:
            print_warning("Could not automatically add to PATH")
            print_info(f"Please manually add to your PATH: {install_dir}")


def add_to_windows_path(directory):
    """Add directory to Windows user PATH"""
    try:
        # Use setx command to modify user PATH
        # Get current PATH first
        result = subprocess.run(
            ['powershell', '-Command', '[Environment]::GetEnvironmentVariable("PATH", "User")'],
            capture_output=True,
            text=True,
            check=True
        )
        current_path = result.stdout.strip()

        # Check if already in PATH
        if str(directory).lower() in current_path.lower():
            return True

        # Add to PATH
        new_path = f'{current_path};{directory}' if current_path else str(directory)
        subprocess.run(
            ['powershell', '-Command', f'[Environment]::SetEnvironmentVariable("PATH", "{new_path}", "User")'],
            check=True,
            capture_output=True
        )
        return True
    except Exception as e:
        print_error(f"PATH update failed: {e}")
        return False


def cmd_install(args):
    """Install command"""
    print_info("Installing samantha-llm...")

    # Check if already installed
    if is_installed():
        print_warning("samantha-llm is already installed.")
        print_info(f"Installed at: {get_install_path()}")
        print_info(f"Config: {get_config_file()}")
        print()

        response = input("Do you want to reinstall? [y/N] ")
        if response.lower() not in ['y', 'yes']:
            print_info("Installation cancelled.")
            return 0

        print_info("Reinstalling...")

    # Create config
    create_config()

    # Platform-specific installation
    system = get_platform()
    if system == 'windows':
        install_windows()
    else:
        install_unix()

    print()
    print_success("Installation complete!")
    print()
    print_info(f"Installed to: {get_install_path()}")
    print_info(f"Config: {get_config_file()}")
    print_info(f"Repo path: {get_repo_dir()}")
    print()

    # Check PATH and warn if needed
    if not check_path():
        print_warning("The install directory is not in your PATH!")
        print()
        system = get_platform()
        if system == 'windows':
            print("Run this command in PowerShell:")
            print()
            print(f'    $env:PATH += ";{get_install_dir()}"')
            print()
            print("Or restart your terminal for persistent PATH changes.")
        else:
            print("Add the following line to your shell profile (~/.bashrc, ~/.zshrc, etc.):")
            print()
            print(f'    export PATH="${{HOME}}/.local/bin:${{PATH}}"')
            print()
            print("Then restart your shell or run:")
            print()
            shell_rc = '~/.zshrc' if Path.home() / '.zshrc' else '~/.bashrc'
            print(f"    source {shell_rc}")
        print()
    else:
        print_success("The samantha-llm command is ready to use!")

    return 0


def cmd_uninstall(args):
    """Uninstall command"""
    print_info("Uninstalling samantha-llm...")

    if not is_installed():
        print_warning("samantha-llm is not installed.")
        return 0

    install_path = get_install_path()
    install_dir = get_install_dir()
    config_dir = get_config_dir()
    system = get_platform()

    # Remove install files
    if system == 'windows':
        # Remove .bat wrapper
        if install_path.exists():
            print_info(f"Removing batch wrapper: {install_path}")
            install_path.unlink()

        # Remove copied Python script
        script_copy = install_dir / 'samantha-llm.py'
        if script_copy.exists():
            print_info(f"Removing script copy: {script_copy}")
            script_copy.unlink()

        # Remove directory if empty
        try:
            install_dir.rmdir()
            print_info(f"Removed install directory: {install_dir}")
        except OSError:
            pass  # Directory not empty, leave it
    else:
        # Remove symlink
        if install_path.exists() or install_path.is_symlink():
            print_info(f"Removing symlink: {install_path}")
            install_path.unlink()

    # Ask about config removal
    print()
    response = input(f"Do you want to remove the config directory ({config_dir})? [y/N] ")
    if response.lower() in ['y', 'yes']:
        print_info(f"Removing config directory: {config_dir}")
        shutil.rmtree(config_dir)
    else:
        print_info(f"Config directory preserved: {config_dir}")

    print()
    print_success("Uninstallation complete!")

    return 0


def cmd_status(args):
    """Status command"""
    print("Samantha Hartwell LLM - Installation Status")
    print("=" * 44)
    print()

    # Check installation
    if is_installed():
        print_success("Installed: Yes")
        install_path = get_install_path()
        print(f"  Location: {install_path}")

        system = get_platform()
        if system == 'windows':
            script_copy = get_install_dir() / 'samantha-llm.py'
            if script_copy.exists():
                print(f"  Script: {script_copy}")
        else:
            if install_path.is_symlink():
                print(f"  Target: {install_path.resolve()}")
    else:
        print_error("Installed: No")
        install_path = get_install_path()
        if install_path.exists():
            print("  Note: Install file exists but config is missing")
        config_file = get_config_file()
        if config_file.exists():
            print("  Note: Config exists but install file is missing")

    print()

    # Check config
    config_file = get_config_file()
    if config_file.exists():
        print_success("Config: Found")
        print(f"  Location: {config_file}")

        # Parse config
        try:
            config = {}
            for line in config_file.read_text().splitlines():
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    config[key] = value.strip('"')

            if 'SAMANTHA_REPO_PATH' in config:
                print(f"  Repo path: {config['SAMANTHA_REPO_PATH']}")
            if 'SAMANTHA_VERSION' in config:
                print(f"  Version: {config['SAMANTHA_VERSION']}")
            if 'SAMANTHA_PLATFORM' in config:
                print(f"  Platform: {config['SAMANTHA_PLATFORM']}")
        except Exception:
            pass
    else:
        print_error("Config: Not found")
        print(f"  Expected: {config_file}")

    print()

    # Check PATH
    if check_path():
        print_success("PATH: Configured correctly")
        print(f"  {get_install_dir()} is in PATH")
    else:
        print_warning("PATH: Not configured")
        print(f"  {get_install_dir()} is not in PATH")

        system = get_platform()
        if system == 'windows':
            print("  Run in PowerShell: $env:PATH += \";{get_install_dir()}\"")
        else:
            print(f"  Add to shell profile: export PATH=\"${{HOME}}/.local/bin:${{PATH}}\"")

    print()

    # Check repo directory
    repo_dir = get_repo_dir()
    git_dir = repo_dir / '.git'

    if git_dir.exists():
        print_success("Repo: Valid git repository")
        print(f"  Location: {repo_dir}")

        # Show current branch if git is available
        try:
            result = subprocess.run(
                ['git', '-C', str(repo_dir), 'branch', '--show-current'],
                capture_output=True,
                text=True,
                check=True
            )
            branch = result.stdout.strip()
            if branch:
                print(f"  Branch: {branch}")
        except Exception:
            pass
    else:
        print_warning("Repo: Not a git repository")
        print(f"  Location: {repo_dir}")

    return 0


def cmd_help(args):
    """Help command"""
    print("""samantha-llm - Samantha Hartwell LLM Management Tool

Usage:
    samantha-llm install    Install samantha-llm and configure environment
    samantha-llm uninstall  Remove samantha-llm installation
    samantha-llm link       Link current directory to samantha-llm (create .ai-cerebrum symlink)
    samantha-llm unlink     Unlink current directory from samantha-llm (remove .ai-cerebrum symlink)
    samantha-llm status     Show installation status and configuration
    samantha-llm version    Show version information
    samantha-llm help       Show this help message

Description:
    This tool manages the installation and configuration of the Samantha
    Hartwell LLM memory system. After installation, the samantha-llm command
    will be available system-wide.

    Use 'link' to activate samantha-llm in a project directory, and 'unlink'
    to deactivate it. This creates/removes a .ai-cerebrum symlink that provides
    access to the samantha-llm repository and memory system.

    Supports Linux, macOS, and Windows.

Examples:
    # Install samantha-llm system-wide
    ./samantha-llm install

    # Link a project directory to samantha-llm
    cd /path/to/project
    samantha-llm link

    # Check installation status
    samantha-llm status

    # Unlink a project directory
    cd /path/to/project
    samantha-llm unlink

    # Uninstall samantha-llm
    samantha-llm uninstall

Platform-Specific Notes:
    Linux/macOS: Installs to ~/.local/bin using symlink
    Windows:     Installs to %LOCALAPPDATA%\\Programs\\samantha-llm using batch wrapper
""")
    return 0


def cmd_version(args):
    """Version command"""
    print(f"samantha-llm version {VERSION}")
    print(f"Platform: {get_platform()}")
    print(f"Python: {sys.version.split()[0]}")
    return 0


def cmd_link(args):
    """Link command - create .ai-cerebrum symlink in current directory"""
    cwd = Path.cwd()
    symlink_path = cwd / '.ai-cerebrum'

    # Get repo path from config
    config_file = get_config_file()
    if not config_file.exists():
        print_error("samantha-llm is not installed")
        print_info("Run 'samantha-llm install' first")
        return 1

    # Parse config to get repo path
    try:
        config = {}
        for line in config_file.read_text().splitlines():
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                config[key] = value.strip('"')

        if 'SAMANTHA_REPO_PATH' not in config:
            print_error("Config file is missing SAMANTHA_REPO_PATH")
            return 1

        repo_path = Path(config['SAMANTHA_REPO_PATH'])
    except Exception as e:
        print_error(f"Failed to read config: {e}")
        return 1

    # Check if repo path exists
    if not repo_path.exists():
        print_error(f"Repository not found: {repo_path}")
        print_info("Please reinstall samantha-llm")
        return 1

    # Check if symlink already exists
    if symlink_path.exists() or symlink_path.is_symlink():
        # Check if it points to the correct location
        if symlink_path.is_symlink():
            current_target = symlink_path.resolve()
            if current_target == repo_path:
                print_success(f"Already linked to samantha-llm")
                print_info(f"  Current directory: {cwd}")
                print_info(f"  Linked to: {repo_path}")
                return 0
            else:
                print_warning(f"Symlink exists but points to wrong location")
                print_info(f"  Current target: {current_target}")
                print_info(f"  Expected target: {repo_path}")
                print()
                response = input("Do you want to relink to the correct location? [y/N] ")
                if response.lower() not in ['y', 'yes']:
                    print_info("Link cancelled")
                    return 0
                print_info("Removing old symlink...")
                symlink_path.unlink()
        else:
            print_error(f"A file or directory named '.ai-cerebrum' already exists")
            print_info(f"  Location: {symlink_path}")
            print_info("Please remove it manually before linking")
            return 1

    # Create symlink
    try:
        print_info(f"Creating symlink: {symlink_path} -> {repo_path}")
        symlink_path.symlink_to(repo_path)
        print()
        print_success("Successfully linked to samantha-llm!")
        print()
        print_info(f"  Current directory: {cwd}")
        print_info(f"  Linked to: {repo_path}")
        print()
        print_info("You can now access samantha-llm via .ai-cerebrum/")
        print_info("Example: cat .ai-cerebrum/BOOTSTRAP_PROMPT.md")
        return 0
    except Exception as e:
        print_error(f"Failed to create symlink: {e}")
        return 1


def cmd_unlink(args):
    """Unlink command - remove .ai-cerebrum symlink from current directory"""
    cwd = Path.cwd()
    symlink_path = cwd / '.ai-cerebrum'

    # Check if symlink exists
    if not symlink_path.exists() and not symlink_path.is_symlink():
        print_warning("Not linked - no .ai-cerebrum symlink found")
        print_info(f"  Current directory: {cwd}")
        return 0

    # Check if it's actually a symlink
    if not symlink_path.is_symlink():
        print_error(f"'.ai-cerebrum' exists but is not a symlink")
        print_info(f"  Location: {symlink_path}")
        print_info("Please remove it manually")
        return 1

    # Show what we're unlinking
    target = symlink_path.resolve()
    print_info(f"Unlinking from samantha-llm...")
    print_info(f"  Current directory: {cwd}")
    print_info(f"  Currently linked to: {target}")
    print()

    # Ask for confirmation
    response = input("Remove .ai-cerebrum symlink? [y/N] ")
    if response.lower() not in ['y', 'yes']:
        print_info("Unlink cancelled")
        return 0

    # Remove symlink
    try:
        symlink_path.unlink()
        print()
        print_success("Successfully unlinked!")
        print_info(f"  Removed: {symlink_path}")
        return 0
    except Exception as e:
        print_error(f"Failed to remove symlink: {e}")
        return 1


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        prog='samantha-llm',
        description='Samantha Hartwell LLM Management Tool',
        add_help=False
    )
    parser.add_argument('command', nargs='?', default='help',
                        choices=['install', 'uninstall', 'status', 'link', 'unlink', 'help', 'version'],
                        help='Command to execute')

    args = parser.parse_args()

    commands = {
        'install': cmd_install,
        'uninstall': cmd_uninstall,
        'status': cmd_status,
        'link': cmd_link,
        'unlink': cmd_unlink,
        'help': cmd_help,
        'version': cmd_version,
    }

    return commands[args.command](args)


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print()
        print_warning("Cancelled by user")
        sys.exit(130)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)
