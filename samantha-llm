#!/usr/bin/env python3
"""
samantha-llm - Installation and management script for Samantha Hartwell LLM

Cross-platform installer supporting Linux, macOS, and Windows.
Version: 0.3.0
"""

import argparse
import json
import os
import platform
import shutil
import subprocess
import sys
from pathlib import Path
from datetime import datetime


# Filename
FILENAME = os.path.basename(__file__)

# Version
VERSION = "0.4.1"

# ANSI color codes
class Colors:
    RED = '\033[0;31m'
    GREEN = '\033[0;32m'
    YELLOW = '\033[1;33m'
    BLUE = '\033[0;34m'
    NC = '\033[0m'  # No Color

    @classmethod
    def supports_color(cls):
        """Check if terminal supports color"""
        if platform.system() == 'Windows':
            # Windows 10+ supports ANSI colors with VT100 emulation
            return True
        return hasattr(sys.stdout, 'isatty') and sys.stdout.isatty()


def print_info(message):
    """Print info message"""
    if Colors.supports_color():
        print(f"{Colors.BLUE}[INFO]{Colors.NC} {message}")
    else:
        print(f"[INFO] {message}")


def print_success(message):
    """Print success message"""
    if Colors.supports_color():
        print(f"{Colors.GREEN}[SUCCESS]{Colors.NC} {message}")
    else:
        print(f"[SUCCESS] {message}")


def print_warning(message):
    """Print warning message"""
    if Colors.supports_color():
        print(f"{Colors.YELLOW}[WARNING]{Colors.NC} {message}")
    else:
        print(f"[WARNING] {message}")


def print_error(message):
    """Print error message"""
    if Colors.supports_color():
        print(f"{Colors.RED}[ERROR]{Colors.NC} {message}")
    else:
        print(f"[ERROR] {message}")


def get_platform():
    """Get platform name (linux, darwin, windows)"""
    return platform.system().lower()


def get_install_dir():
    """Get platform-appropriate install directory"""
    system = get_platform()
    if system == 'windows':
        return Path(os.environ['LOCALAPPDATA']) / 'Programs' / 'samantha-llm'
    else:  # Linux, Darwin (macOS)
        return Path.home() / '.local' / 'bin'


def get_config_dir():
    """Get platform-appropriate config directory"""
    system = get_platform()
    if system == 'windows':
        return Path(os.environ['APPDATA']) / 'samantha-llm'
    else:  # Linux, Darwin (macOS)
        return Path.home() / '.config' / 'samantha-llm'


def get_script_name():
    """Get platform-appropriate script name"""
    system = get_platform()
    if system == 'windows':
        return 'samantha-llm.bat'
    else:
        return 'samantha-llm'


def get_repo_dir():
    """Get the samantha-llm repository directory"""
    # This script should be in the root of the repo
    return Path(__file__).resolve().parent


def get_config_file():
    """Get config file path"""
    return get_config_dir() / 'config.json'


def get_old_config_file():
    """Get old config file path (for migration)"""
    return get_config_dir() / 'config'


def read_config():
    """Read JSON config file"""
    config_file = get_config_file()
    if not config_file.exists():
        return None

    try:
        with open(config_file, 'r') as f:
            return json.load(f)
    except Exception as e:
        print_error(f"Failed to read config: {e}")
        return None


def write_config(config):
    """Write JSON config file"""
    config_file = get_config_file()
    config_dir = get_config_dir()

    # Create config directory if needed
    config_dir.mkdir(parents=True, exist_ok=True)

    try:
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        return True
    except Exception as e:
        print_error(f"Failed to write config: {e}")
        return False


def migrate_old_config():
    """Migrate old shell-style config to JSON"""
    old_config_file = get_old_config_file()
    new_config_file = get_config_file()

    # Check if old config exists and new doesn't
    if not old_config_file.exists() or new_config_file.exists():
        return False

    print_info("Migrating old config to JSON format...")

    # Parse old config
    try:
        old_config = {}
        for line in old_config_file.read_text().splitlines():
            line = line.strip()
            if line and not line.startswith('#') and '=' in line:
                key, value = line.split('=', 1)
                old_config[key] = value.strip('"')

        # Create new JSON config
        new_config = {
            'version': old_config.get('SAMANTHA_VERSION', VERSION),
            'platform': old_config.get('SAMANTHA_PLATFORM', get_platform()),
            'repo_path': old_config.get('SAMANTHA_REPO_PATH', str(get_repo_dir())),
            'agents': {},
            'workspaces': {}
        }

        # Write new config
        if write_config(new_config):
            # Backup old config
            backup_file = old_config_file.with_suffix('.backup')
            shutil.copy2(old_config_file, backup_file)
            print_success(f"Config migrated successfully!")
            print_info(f"  Old config backed up to: {backup_file}")
            print_info(f"  New config: {new_config_file}")
            return True
        else:
            return False

    except Exception as e:
        print_error(f"Config migration failed: {e}")
        return False


def get_install_path():
    """Get full install path"""
    return get_install_dir() / get_script_name()


def is_installed():
    """Check if samantha-llm is installed"""
    install_path = get_install_path()
    config_file = get_config_file()

    system = get_platform()
    if system == 'windows':
        # On Windows, check if .bat file exists and config exists
        return install_path.exists() and config_file.exists()
    else:
        # On Unix, check if symlink exists and config exists
        return install_path.is_symlink() and config_file.exists()


def check_path():
    """Check if install directory is in PATH"""
    install_dir = str(get_install_dir())
    path_env = os.environ.get('PATH', '')

    if platform.system() == 'Windows':
        # Windows is case-insensitive and uses ; as separator
        paths = [p.lower() for p in path_env.split(';')]
        return install_dir.lower() in paths
    else:
        # Unix uses : as separator
        return install_dir in path_env.split(':')


def create_config():
    """Create JSON config file"""
    repo_dir = get_repo_dir()

    print_info(f"Creating config file: {get_config_file()}")

    config = {
        'version': VERSION,
        'platform': get_platform(),
        'repo_path': str(repo_dir),
        'agents': {},
        'workspaces': {}
    }

    return write_config(config)


def install_unix():
    """Install on Unix-like systems (Linux, macOS) using symlink"""
    install_dir = get_install_dir()
    install_path = get_install_path()
    repo_dir = get_repo_dir()
    source_script = repo_dir / FILENAME

    # Create install directory
    if not install_dir.exists():
        print_info(f"Creating install directory: {install_dir}")
        install_dir.mkdir(parents=True, exist_ok=True)

    # Remove existing symlink if present
    if install_path.exists() or install_path.is_symlink():
        print_info("Removing existing symlink...")
        install_path.unlink()

    # Create symlink
    print_info(f"Creating symlink: {install_path} -> {source_script}")
    install_path.symlink_to(source_script)

    # Make source script executable
    source_script.chmod(source_script.stat().st_mode | 0o111)


def install_windows():
    """Install on Windows by copying script and creating batch wrapper"""
    install_dir = get_install_dir()
    install_path = get_install_path()
    repo_dir = get_repo_dir()
    source_script = repo_dir / FILENAME

    # Create install directory
    if not install_dir.exists():
        print_info(f"Creating install directory: {install_dir}")
        install_dir.mkdir(parents=True, exist_ok=True)

    # Copy Python script
    script_target = install_dir / FILENAME
    print_info(f"Copying script: {source_script} -> {script_target}")
    shutil.copy2(source_script, script_target)

    # Create batch wrapper
    print_info(f"Creating batch wrapper: {install_path}")
    wrapper_content = f'@echo off\npython "{script_target}" %*\n'
    install_path.write_text(wrapper_content)

    # Add to PATH
    if not check_path():
        print_info("Adding install directory to PATH...")
        if add_to_windows_path(install_dir):
            print_success("Added to PATH successfully")
            print_warning("Please restart your terminal/PowerShell for PATH changes to take effect")
        else:
            print_warning("Could not automatically add to PATH")
            print_info(f"Please manually add to your PATH: {install_dir}")


def add_to_windows_path(directory):
    """Add directory to Windows user PATH"""
    try:
        # Use setx command to modify user PATH
        # Get current PATH first
        result = subprocess.run(
            ['powershell', '-Command', '[Environment]::GetEnvironmentVariable("PATH", "User")'],
            capture_output=True,
            text=True,
            check=True
        )
        current_path = result.stdout.strip()

        # Check if already in PATH
        if str(directory).lower() in current_path.lower():
            return True

        # Add to PATH
        new_path = f'{current_path};{directory}' if current_path else str(directory)
        subprocess.run(
            ['powershell', '-Command', f'[Environment]::SetEnvironmentVariable("PATH", "{new_path}", "User")'],
            check=True,
            capture_output=True
        )
        return True
    except Exception as e:
        print_error(f"PATH update failed: {e}")
        return False


def cmd_install(args):
    """Install command"""
    print_info("Installing samantha-llm...")

    # Check for old config and migrate
    migrate_old_config()

    # Check if already installed
    if is_installed():
        print_warning("samantha-llm is already installed.")
        print_info(f"Installed at: {get_install_path()}")
        print_info(f"Config: {get_config_file()}")
        print()

        response = input("Do you want to reinstall? [y/N] ")
        if response.lower() not in ['y', 'yes']:
            print_info("Installation cancelled.")
            return 0

        print_info("Reinstalling...")

    # Create config
    if not create_config():
        print_error("Failed to create config file")
        return 1

    # Platform-specific installation
    system = get_platform()
    if system == 'windows':
        install_windows()
    else:
        install_unix()

    print()
    print_success("Installation complete!")
    print()
    print_info(f"Installed to: {get_install_path()}")
    print_info(f"Config: {get_config_file()}")
    print_info(f"Repo path: {get_repo_dir()}")
    print()

    # Check PATH and warn if needed
    if not check_path():
        print_warning("The install directory is not in your PATH!")
        print()
        system = get_platform()
        if system == 'windows':
            print("Run this command in PowerShell:")
            print()
            print(f'    $env:PATH += ";{get_install_dir()}"')
            print()
            print("Or restart your terminal for persistent PATH changes.")
        else:
            print("Add the following line to your shell profile (~/.bashrc, ~/.zshrc, etc.):")
            print()
            print(f'    export PATH="${{HOME}}/.local/bin:${{PATH}}"')
            print()
            print("Then restart your shell or run:")
            print()
            shell_rc = '~/.zshrc' if Path.home() / '.zshrc' else '~/.bashrc'
            print(f"    source {shell_rc}")
        print()
    else:
        print_success("The samantha-llm command is ready to use!")

    return 0


def cmd_uninstall(args):
    """Uninstall command"""
    print_info("Uninstalling samantha-llm...")

    if not is_installed():
        print_warning("samantha-llm is not installed.")
        return 0

    install_path = get_install_path()
    install_dir = get_install_dir()
    config_dir = get_config_dir()
    system = get_platform()

    # Remove install files
    if system == 'windows':
        # Remove .bat wrapper
        if install_path.exists():
            print_info(f"Removing batch wrapper: {install_path}")
            install_path.unlink()

        # Remove copied Python script
        script_copy = install_dir / FILENAME
        if script_copy.exists():
            print_info(f"Removing script copy: {script_copy}")
            script_copy.unlink()

        # Remove directory if empty
        try:
            install_dir.rmdir()
            print_info(f"Removed install directory: {install_dir}")
        except OSError:
            pass  # Directory not empty, leave it
    else:
        # Remove symlink
        if install_path.exists() or install_path.is_symlink():
            print_info(f"Removing symlink: {install_path}")
            install_path.unlink()

    # Ask about config removal
    print()
    response = input(f"Do you want to remove the config directory ({config_dir})? [y/N] ")
    if response.lower() in ['y', 'yes']:
        print_info(f"Removing config directory: {config_dir}")
        shutil.rmtree(config_dir)
    else:
        print_info(f"Config directory preserved: {config_dir}")

    print()
    print_success("Uninstallation complete!")

    return 0


def cmd_status(args):
    """Status command"""
    print("Samantha Hartwell LLM - Installation Status")
    print("=" * 44)
    print()

    # Check installation
    if is_installed():
        print_success("Installed: Yes")
        install_path = get_install_path()
        print(f"  Location: {install_path}")

        system = get_platform()
        if system == 'windows':
            script_copy = get_install_dir() / FILENAME
            if script_copy.exists():
                print(f"  Script: {script_copy}")
        else:
            if install_path.is_symlink():
                print(f"  Target: {install_path.resolve()}")
    else:
        print_error("Installed: No")
        install_path = get_install_path()
        if install_path.exists():
            print("  Note: Install file exists but config is missing")
        config_file = get_config_file()
        if config_file.exists():
            print("  Note: Config exists but install file is missing")

    print()

    # Check config
    config_file = get_config_file()
    if config_file.exists():
        print_success("Config: Found")
        print(f"  Location: {config_file}")

        # Parse JSON config
        config = read_config()
        if config:
            if 'repo_path' in config:
                print(f"  Repo path: {config['repo_path']}")
            if 'version' in config:
                print(f"  Version: {config['version']}")
            if 'platform' in config:
                print(f"  Platform: {config['platform']}")
            if 'default_agent' in config:
                print(f"  Default agent: {config['default_agent']}")

            # Show configured agents
            if 'agents' in config and config['agents']:
                print(f"  Configured agents: {', '.join(config['agents'].keys())}")
    else:
        print_error("Config: Not found")
        print(f"  Expected: {config_file}")

    print()

    # Check PATH
    if check_path():
        print_success("PATH: Configured correctly")
        print(f"  {get_install_dir()} is in PATH")
    else:
        print_warning("PATH: Not configured")
        print(f"  {get_install_dir()} is not in PATH")

        system = get_platform()
        if system == 'windows':
            print("  Run in PowerShell: $env:PATH += \";{get_install_dir()}\"")
        else:
            print(f"  Add to shell profile: export PATH=\"${{HOME}}/.local/bin:${{PATH}}\"")

    print()

    # Check repo directory
    repo_dir = get_repo_dir()
    git_dir = repo_dir / '.git'

    if git_dir.exists():
        print_success("Repo: Valid git repository")
        print(f"  Location: {repo_dir}")

        # Show current branch if git is available
        try:
            result = subprocess.run(
                ['git', '-C', str(repo_dir), 'branch', '--show-current'],
                capture_output=True,
                text=True,
                check=True
            )
            branch = result.stdout.strip()
            if branch:
                print(f"  Branch: {branch}")
        except Exception:
            pass
    else:
        print_warning("Repo: Not a git repository")
        print(f"  Location: {repo_dir}")

    return 0


def cmd_help(args):
    """Help command"""
    print("""samantha-llm - Samantha Hartwell LLM Management Tool

Usage:
    samantha-llm install           Install samantha-llm and configure environment
    samantha-llm uninstall         Remove samantha-llm installation
    samantha-llm setup             Configure an agent for LLM sessions
    samantha-llm setup --default AGENT  Set default agent
    samantha-llm agents            List configured agents
    samantha-llm start [AGENT]     Start a Samantha Hartwell session (uses default agent if not specified)
    samantha-llm link              Link current directory to samantha-llm (create .ai-cerebrum symlink)
    samantha-llm unlink            Unlink current directory from samantha-llm (remove .ai-cerebrum symlink)
    samantha-llm qmd install       Install qmd (memory search engine) and dependencies
    samantha-llm qmd status        Show qmd installation status
    samantha-llm qmd check         Quick check if qmd is available
    samantha-llm memories index    Index cerebrum files for semantic search
    samantha-llm status            Show installation status and configuration
    samantha-llm version           Show version information
    samantha-llm help              Show this help message

Description:
    This tool manages the installation and configuration of the Samantha
    Hartwell LLM memory system. After installation, the samantha-llm command
    will be available system-wide.

    Use 'setup' to configure an agent (Claude Code, Abacus.ai, GitHub Copilot,
    or custom). Use 'start' to begin a Samantha session in the current
    workspace - it will automatically link the workspace, run the agent with
    the bootstrap prompt, and clean up when the session ends.

    Use 'link' to manually activate samantha-llm in a project directory, and
    'unlink' to deactivate it. This creates/removes a .ai-cerebrum symlink that
    provides access to the samantha-llm repository and memory system.

    Supports Linux, macOS, and Windows.

Examples:
    # Install samantha-llm system-wide
    ./samantha-llm install

    # Configure an agent
    samantha-llm setup

    # Start a Samantha session (uses default agent)
    cd /path/to/project
    samantha-llm start

    # Start a session with a specific agent
    samantha-llm start claude

    # Link a project directory to samantha-llm (manual)
    cd /path/to/project
    samantha-llm link

    # Check installation status
    samantha-llm status

    # List configured agents
    samantha-llm agents

    # Change default agent
    samantha-llm setup --default claude

    # Unlink a project directory
    cd /path/to/project
    samantha-llm unlink

    # Uninstall samantha-llm
    samantha-llm uninstall

Platform-Specific Notes:
    Linux/macOS: Installs to ~/.local/bin using symlink
    Windows:     Installs to %LOCALAPPDATA%\\Programs\\samantha-llm using batch wrapper
""")
    return 0


def cmd_version(args):
    """Version command"""
    print(f"samantha-llm version {VERSION}")
    print(f"Platform: {get_platform()}")
    print(f"Python: {sys.version.split()[0]}")
    return 0


def cmd_link(args):
    """Link command - create .ai-cerebrum symlink in current directory"""
    cwd = Path.cwd()
    symlink_path = cwd / '.ai-cerebrum'

    # Get repo path from config
    config = read_config()
    if not config:
        print_error("samantha-llm is not installed")
        print_info("Run 'samantha-llm install' first")
        return 1

    if 'repo_path' not in config:
        print_error("Config file is missing repo_path")
        return 1

    repo_path = Path(config['repo_path'])

    # Check if repo path exists
    if not repo_path.exists():
        print_error(f"Repository not found: {repo_path}")
        print_info("Please reinstall samantha-llm")
        return 1

    # Check if symlink already exists
    if symlink_path.exists() or symlink_path.is_symlink():
        # Check if it points to the correct location
        if symlink_path.is_symlink():
            current_target = symlink_path.resolve()
            if current_target == repo_path:
                print_success(f"Already linked to samantha-llm")
                print_info(f"  Current directory: {cwd}")
                print_info(f"  Linked to: {repo_path}")
                return 0
            else:
                print_warning(f"Symlink exists but points to wrong location")
                print_info(f"  Current target: {current_target}")
                print_info(f"  Expected target: {repo_path}")
                print()
                response = input("Do you want to relink to the correct location? [y/N] ")
                if response.lower() not in ['y', 'yes']:
                    print_info("Link cancelled")
                    return 0
                print_info("Removing old symlink...")
                symlink_path.unlink()
        else:
            print_error(f"A file or directory named '.ai-cerebrum' already exists")
            print_info(f"  Location: {symlink_path}")
            print_info("Please remove it manually before linking")
            return 1

    # Create symlink
    try:
        print_info(f"Creating symlink: {symlink_path} -> {repo_path}")
        symlink_path.symlink_to(repo_path)

        # Track this workspace as manually linked
        if 'workspaces' not in config:
            config['workspaces'] = {}
        config['workspaces'][str(cwd)] = {
            'linked_at': datetime.now().isoformat(),
            'manual': True
        }
        write_config(config)

        print()
        print_success("Successfully linked to samantha-llm!")
        print()
        print_info(f"  Current directory: {cwd}")
        print_info(f"  Linked to: {repo_path}")
        print()
        print_info("You can now access samantha-llm via .ai-cerebrum/")
        print_info("Example: cat .ai-cerebrum/BOOTSTRAP_PROMPT.md")
        return 0
    except Exception as e:
        print_error(f"Failed to create symlink: {e}")
        return 1


def cmd_unlink(args):
    """Unlink command - remove .ai-cerebrum symlink from current directory"""
    cwd = Path.cwd()
    symlink_path = cwd / '.ai-cerebrum'

    # Check if symlink exists
    if not symlink_path.exists() and not symlink_path.is_symlink():
        print_warning("Not linked - no .ai-cerebrum symlink found")
        print_info(f"  Current directory: {cwd}")
        return 0

    # Check if it's actually a symlink
    if not symlink_path.is_symlink():
        print_error(f"'.ai-cerebrum' exists but is not a symlink")
        print_info(f"  Location: {symlink_path}")
        print_info("Please remove it manually")
        return 1

    # Show what we're unlinking
    target = symlink_path.resolve()
    print_info(f"Unlinking from samantha-llm...")
    print_info(f"  Current directory: {cwd}")
    print_info(f"  Currently linked to: {target}")
    print()

    # Ask for confirmation
    response = input("Remove .ai-cerebrum symlink? [y/N] ")
    if response.lower() not in ['y', 'yes']:
        print_info("Unlink cancelled")
        return 0

    # Remove symlink
    try:
        symlink_path.unlink()

        # Remove from workspace tracking
        config = read_config()
        if config and 'workspaces' in config and str(cwd) in config['workspaces']:
            del config['workspaces'][str(cwd)]
            write_config(config)

        print()
        print_success("Successfully unlinked!")
        print_info(f"  Removed: {symlink_path}")
        return 0
    except Exception as e:
        print_error(f"Failed to remove symlink: {e}")
        return 1


def cmd_setup(args):
    """Setup command - configure agents"""
    print_info("Samantha LLM Agent Setup")
    print()

    # Check if installed
    config = read_config()
    if not config:
        print_error("samantha-llm is not installed")
        print_info("Run 'samantha-llm install' first")
        return 1

    # Check if --default flag is used
    if hasattr(args, 'default_agent') and args.default_agent:
        # Just change default agent
        agent_name = args.default_agent
        if 'agents' not in config or agent_name not in config['agents']:
            print_error(f"Agent '{agent_name}' is not configured")
            print_info("Available agents: " + ', '.join(config.get('agents', {}).keys()))
            return 1

        config['default_agent'] = agent_name
        if write_config(config):
            print_success(f"Default agent set to: {agent_name}")
            return 0
        else:
            return 1

    # Interactive setup
    print("Select your preferred Agentic LLM tool:")
    print()
    print("1) Claude Code")
    print("2) Abacus.ai")
    print("3) GitHub Copilot")
    print("4) Other (manual setup)")
    print()

    choice = input("Enter your choice [1-4]: ").strip()

    agent_config = None
    agent_name = None

    if choice == '1':
        agent_name = 'claude'
        agent_config = {
            'command': 'claude',
            'bootstrap_file': 'BOOTSTRAP_PROMPT.md'
        }
        print_info("Configuring Claude Code...")
    elif choice == '2':
        agent_name = 'abacus'
        agent_config = {
            'command': 'npx abacusai',
            'bootstrap_file': 'BOOTSTRAP_PROMPT.md'
        }
        print_info("Configuring Abacus.ai...")
    elif choice == '3':
        agent_name = 'copilot'
        agent_config = {
            'command': 'npx copilot -i',
            'bootstrap_file': 'BOOTSTRAP_PROMPT.md'
        }
        print_info("Configuring GitHub Copilot...")
    elif choice == '4':
        print()
        print_info("Manual agent setup")
        agent_name = input("Enter agent name (e.g., 'myagent'): ").strip()
        if not agent_name:
            print_error("Agent name cannot be empty")
            return 1

        command = input("Enter command to run agent (e.g., 'npx myagent'): ").strip()
        if not command:
            print_error("Command cannot be empty")
            return 1

        bootstrap_file = input("Enter bootstrap file name [BOOTSTRAP_PROMPT.md]: ").strip()
        if not bootstrap_file:
            bootstrap_file = 'BOOTSTRAP_PROMPT.md'

        agent_config = {
            'command': command,
            'bootstrap_file': bootstrap_file
        }
        print_info(f"Configuring {agent_name}...")
    else:
        print_error("Invalid choice")
        return 1

    # Add agent to config
    if 'agents' not in config:
        config['agents'] = {}

    config['agents'][agent_name] = agent_config

    # Set as default if it's the first agent or user confirms
    if 'default_agent' not in config or not config.get('agents'):
        config['default_agent'] = agent_name
        print_info(f"Setting {agent_name} as default agent")
    else:
        print()
        response = input(f"Set {agent_name} as default agent? [Y/n] ").strip().lower()
        if response in ['', 'y', 'yes']:
            config['default_agent'] = agent_name

    # Save config
    if write_config(config):
        print()
        print_success(f"Agent '{agent_name}' configured successfully!")
        print_info(f"  Command: {agent_config['command']}")
        print_info(f"  Bootstrap: {agent_config['bootstrap_file']}")
        if config.get('default_agent') == agent_name:
            print_info(f"  Default: Yes")
        print()
        print_info("You can now use 'samantha-llm start' to begin a session")
        return 0
    else:
        return 1


def cmd_agents(args):
    """Agents command - list configured agents"""
    config = read_config()
    if not config:
        print_error("samantha-llm is not installed")
        print_info("Run 'samantha-llm install' first")
        return 1

    agents = config.get('agents', {})
    default_agent = config.get('default_agent')

    if not agents:
        print_warning("No agents configured")
        print_info("Run 'samantha-llm setup' to configure an agent")
        return 0

    print("Configured Agents:")
    print("=" * 50)
    print()

    for name, agent_config in agents.items():
        is_default = " (default)" if name == default_agent else ""
        print(f"{name}{is_default}")
        print(f"  Command: {agent_config.get('command', 'N/A')}")
        print(f"  Bootstrap: {agent_config.get('bootstrap_file', 'N/A')}")
        print()

    return 0


def cmd_start(args):
    """Start command - begin a Samantha Hartwell LLM session in current workspace"""
    cwd = Path.cwd()
    symlink_path = cwd / '.ai-cerebrum'

    # Get config
    config = read_config()
    if not config:
        print_error("samantha-llm is not installed")
        print_info("Run 'samantha-llm install' first")
        return 1

    # Check if repo path exists
    if 'repo_path' not in config:
        print_error("Config file is missing repo_path")
        return 1

    repo_path = Path(config['repo_path'])
    if not repo_path.exists():
        print_error(f"Repository not found: {repo_path}")
        print_info("Please reinstall samantha-llm")
        return 1

    # Determine which agent to use
    agent_name = args.agent if hasattr(args, 'agent') and args.agent else config.get('default_agent')

    if not agent_name:
        print_error("No agent configured")
        print_info("Run 'samantha-llm setup' to configure an agent")
        return 1

    agents = config.get('agents', {})
    if agent_name not in agents:
        print_error(f"Agent '{agent_name}' not found")
        print_info("Available agents:")
        for name in agents.keys():
            print_info(f"  - {name}")
        print_info("Run 'samantha-llm agents' to see all configured agents")
        return 1

    agent_config = agents[agent_name]
    agent_command = agent_config.get('command')
    bootstrap_file = agent_config.get('bootstrap_file', 'BOOTSTRAP_PROMPT.md')

    if not agent_command:
        print_error(f"Agent '{agent_name}' has no command configured")
        return 1

    # Check if workspace is already linked
    workspaces = config.get('workspaces', {})
    is_manual_link = str(cwd) in workspaces and workspaces[str(cwd)].get('manual', False)
    auto_linked = False

    # Auto-link if needed
    if not symlink_path.exists() and not symlink_path.is_symlink():
        print_info(f"Auto-linking workspace to samantha-llm...")
        try:
            symlink_path.symlink_to(repo_path)
            auto_linked = True

            # Track as auto-linked workspace
            if 'workspaces' not in config:
                config['workspaces'] = {}
            config['workspaces'][str(cwd)] = {
                'linked_at': datetime.now().isoformat(),
                'manual': False
            }
            write_config(config)

            print_success("Workspace linked")
        except Exception as e:
            print_error(f"Failed to create symlink: {e}")
            return 1
    elif symlink_path.is_symlink():
        # Verify it points to correct location
        current_target = symlink_path.resolve()
        if current_target != repo_path:
            print_error(f"Symlink exists but points to wrong location")
            print_info(f"  Current target: {current_target}")
            print_info(f"  Expected target: {repo_path}")
            print_info("Run 'samantha-llm link' to fix the symlink")
            return 1
    elif symlink_path.exists():
        print_error(f"A file or directory named '.ai-cerebrum' already exists")
        print_info(f"  Location: {symlink_path}")
        print_info("Please remove it manually before starting a session")
        return 1

    # Read bootstrap file
    bootstrap_path = repo_path / bootstrap_file
    if not bootstrap_path.exists():
        print_error(f"Bootstrap file not found: {bootstrap_path}")
        return 1

    try:
        with open(bootstrap_path, 'r') as f:
            bootstrap_content = f.read()
    except Exception as e:
        print_error(f"Failed to read bootstrap file: {e}")
        return 1

    # Prepare agent command
    # Parse command string (handle spaces in command)
    import shlex
    cmd_parts = shlex.split(agent_command)
    cmd_parts.append(bootstrap_content)

    print()
    print_info(f"Starting Samantha Hartwell session with agent '{agent_name}'")
    print_info(f"  Workspace: {cwd}")
    print_info(f"  Command: {agent_command}")
    print()

    # Execute agent command with bootstrap content
    try:
        result = subprocess.run(
            cmd_parts,
            stdin=sys.stdin,
            stdout=sys.stdout,
            stderr=sys.stderr,
            cwd=str(cwd)
        )
        exit_code = result.returncode
    except FileNotFoundError:
        print_error(f"Agent command not found: {agent_command}")
        print_info("Make sure the agent is installed and in your PATH")
        exit_code = 127
    except Exception as e:
        print_error(f"Failed to execute agent: {e}")
        exit_code = 1

    # Cleanup auto-linked workspace
    if auto_linked and not is_manual_link:
        print()
        print_info("Cleaning up auto-linked workspace...")
        try:
            if symlink_path.is_symlink():
                symlink_path.unlink()
            # Remove from config
            if str(cwd) in config.get('workspaces', {}):
                del config['workspaces'][str(cwd)]
                write_config(config)
            print_success("Workspace unlinked")
        except Exception as e:
            print_warning(f"Failed to cleanup workspace: {e}")
            print_info("You may need to run 'samantha-llm unlink' manually")

    return exit_code


# ============================================================================
# QMD Commands
# ============================================================================

def is_command_available(command):
    """Check if a command is available on PATH"""
    return shutil.which(command) is not None


def is_bun_installed():
    """Check if Bun runtime is installed"""
    return is_command_available('bun')


def is_qmd_installed():
    """Check if qmd is installed"""
    return is_command_available('qmd')


def get_qmd_models_dir():
    """Get qmd models directory"""
    return Path.home() / '.cache' / 'qmd' / 'models'


def get_qmd_config_file():
    """Get qmd config file path"""
    return get_config_dir() / 'qmd-config.json'


def install_bun():
    """Install Bun runtime"""
    print_info("Installing Bun runtime...")

    system = get_platform()

    if system == 'windows':
        print_error("Windows is not yet supported for automatic Bun installation")
        print_info("Please install Bun manually: https://bun.sh/docs/installation")
        print_info("Or use WSL (Windows Subsystem for Linux)")
        return False

    # Use official Bun installer for Linux and macOS
    install_cmd = "curl -fsSL https://bun.sh/install | bash"

    print_info("Running: curl -fsSL https://bun.sh/install | bash")
    print_warning("This will download and install Bun to ~/.bun")

    try:
        result = subprocess.run(
            install_cmd,
            shell=True,
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print_error(f"Bun installation failed: {result.stderr}")
            return False

        print_success("Bun installed successfully")

        # Check if Bun is now in PATH
        if not is_bun_installed():
            print_warning("Bun installed but not found in PATH")
            print_info("You may need to restart your shell or run:")
            print_info("  source ~/.bashrc  (or ~/.zshrc)")
            bun_path = Path.home() / '.bun' / 'bin'
            print_info(f"  Or add to PATH: export PATH=\"{bun_path}:$PATH\"")
            return False

        return True

    except Exception as e:
        print_error(f"Failed to install Bun: {e}")
        return False


def install_qmd():
    """Install qmd via Bun"""
    print_info("Installing qmd...")

    if not is_bun_installed():
        print_error("Bun is not installed. Install Bun first with: samantha-llm qmd install-bun")
        return False

    try:
        result = subprocess.run(
            ['bun', 'install', '-g', 'qmd'],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print_error(f"qmd installation failed: {result.stderr}")
            return False

        print_success("qmd installed successfully")

        # Check if qmd is now available
        if not is_qmd_installed():
            print_warning("qmd installed but not found in PATH")
            print_info("You may need to add Bun's global bin directory to PATH")
            return False

        # Create config file
        config_file = get_qmd_config_file()
        config_dir = get_config_dir()
        config_dir.mkdir(parents=True, exist_ok=True)

        qmd_config = {
            "enabled": True,
            "auto_index": True,
            "search_mode": "hybrid",
            "models_path": str(get_qmd_models_dir())
        }

        with open(config_file, 'w') as f:
            json.dump(qmd_config, f, indent=2)

        print_success(f"Created qmd config: {config_file}")
        print()
        print_info("qmd will auto-download models (~2GB) on first use")
        print_info(f"Models will be cached in: {get_qmd_models_dir()}")

        return True

    except Exception as e:
        print_error(f"Failed to install qmd: {e}")
        return False


def cmd_qmd(args):
    """Handle qmd subcommands"""
    subcommand = args.subcommand or 'status'

    if subcommand == 'install':
        # Install both Bun and qmd
        print_info("Installing qmd and dependencies...")
        print()

        # Check if Bun is installed
        if not is_bun_installed():
            if not install_bun():
                print()
                print_error("Failed to install Bun. Cannot continue with qmd installation.")
                return 1
            print()
        else:
            print_success("Bun is already installed")
            print()

        # Install qmd
        if not install_qmd():
            return 1

        print()
        print_success("qmd installation complete!")
        print()
        print_info("Next steps:")
        print_info("  1. Index your cerebrum: samantha-llm memories index")
        print_info("  2. Search memories: samantha-llm memories search <query>")
        return 0

    elif subcommand == 'install-bun':
        # Install only Bun
        if is_bun_installed():
            print_success("Bun is already installed")
            return 0

        if install_bun():
            return 0
        return 1

    elif subcommand == 'status':
        # Show qmd installation status
        print_info("QMD Installation Status:")
        print()

        # Check Bun
        if is_bun_installed():
            try:
                result = subprocess.run(['bun', '--version'], capture_output=True, text=True)
                version = result.stdout.strip()
                print_success(f"Bun: Installed (version {version})")
            except:
                print_success("Bun: Installed")
        else:
            print_error("Bun: Not installed")
            print_info("  Install with: samantha-llm qmd install-bun")

        # Check qmd
        if is_qmd_installed():
            try:
                result = subprocess.run(['qmd', '--version'], capture_output=True, text=True)
                version = result.stdout.strip() if result.stdout else 'unknown'
                print_success(f"qmd: Installed (version {version})")
            except:
                print_success("qmd: Installed")

            # Check for models
            models_dir = get_qmd_models_dir()
            if models_dir.exists():
                model_count = len(list(models_dir.glob('*')))
                if model_count > 0:
                    print_success(f"Models: {model_count} models downloaded")
                else:
                    print_warning("Models: Not yet downloaded (will download on first use)")
            else:
                print_warning("Models: Not yet downloaded (will download on first use)")
        else:
            print_error("qmd: Not installed")
            print_info("  Install with: samantha-llm qmd install")

        # Check config
        config_file = get_qmd_config_file()
        if config_file.exists():
            print_success(f"Config: {config_file}")
        else:
            print_warning("Config: Not created")

        print()

        if not is_bun_installed() or not is_qmd_installed():
            print_info("To install qmd, run: samantha-llm qmd install")
        else:
            print_success("qmd is ready to use!")

        return 0

    elif subcommand == 'check':
        # Quick check (exit code 0 if installed, 1 if not)
        if is_qmd_installed():
            print_success("qmd is installed and available")
            return 0
        else:
            print_error("qmd is not installed")
            return 1

    else:
        print_error(f"Unknown qmd subcommand: {subcommand}")
        print_info("Available subcommands:")
        print_info("  install      - Install qmd and dependencies")
        print_info("  install-bun  - Install only Bun runtime")
        print_info("  status       - Show installation status")
        print_info("  check        - Quick check if qmd is available")
        return 1


# ============================================================================
# Memory Commands
# ============================================================================

def get_cerebrum_path():
    """Get path to cerebrum (samantha-llm repo)"""
    return get_repo_dir()


def get_memory_directories():
    """Get list of memory directories to index"""
    cerebrum = get_cerebrum_path()
    return [
        cerebrum / '.ai' / 'short-term-memory' / '.ai',
        cerebrum / '.ai' / 'long-term-memory' / '.ai',
        cerebrum / '.ai' / 'current-tasks' / '.ai',
        cerebrum / '.ai' / 'work-experience' / '.ai',
    ]


def index_cerebrum():
    """Index cerebrum files with qmd"""
    if not is_qmd_installed():
        print_error("qmd is not installed")
        print_info("Install with: samantha-llm qmd install")
        return False

    print_info("Indexing cerebrum files...")
    print()

    # Get memory directories
    memory_dirs = get_memory_directories()

    # Check which directories exist
    existing_dirs = [d for d in memory_dirs if d.exists()]

    if not existing_dirs:
        print_warning("No memory directories found")
        print_info("Memory directories checked:")
        for d in memory_dirs:
            print_info(f"  {d}")
        return False

    print_info(f"Found {len(existing_dirs)} memory directories:")
    for d in existing_dirs:
        file_count = len(list(d.glob('*.md')))
        print_info(f"  {d.name}: {file_count} files")
    print()

    # Create qmd collection
    collection_name = "samantha-cerebrum"

    # Build qmd command
    # qmd index <collection> <path1> <path2> ...
    cmd = ['qmd', 'index', collection_name]
    for d in existing_dirs:
        cmd.append(str(d))

    # Add context metadata to help qmd understand the files
    cmd.extend([
        '--context',
        'Personal memory system for Samantha Hartwell, an AI software engineer. Contains memories of past work, technical decisions, and ongoing projects.'
    ])

    print_info(f"Creating collection: {collection_name}")
    print_info(f"Indexing {len(existing_dirs)} directories...")

    try:
        result = subprocess.run(
            cmd,
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            print_error(f"Indexing failed: {result.stderr}")
            return False

        # Parse output to show progress
        if result.stdout:
            print()
            print_info("Indexing output:")
            for line in result.stdout.strip().split('\n'):
                if line.strip():
                    print(f"  {line}")

        print()
        print_success(f"Cerebrum indexed successfully!")
        print_info(f"Collection: {collection_name}")

        return True

    except Exception as e:
        print_error(f"Indexing failed: {e}")
        return False


def cmd_memories(args):
    """Handle memory commands"""
    subcommand = args.subcommand or 'help'

    if subcommand == 'index':
        # Index cerebrum files
        if index_cerebrum():
            print()
            print_info("Next steps:")
            print_info("  - Search memories: samantha-llm memories search <query>")
            print_info("  - Check status: qmd list samantha-cerebrum")
            return 0
        return 1

    elif subcommand == 'help' or subcommand not in ['index']:
        # Show help
        print_info("Memory management commands:")
        print()
        print_info("  samantha-llm memories index    - Index cerebrum files for searching")
        print()
        print_info("Coming soon:")
        print_info("  samantha-llm memories search   - Search memories with qmd")
        print()
        print_info("Example:")
        print_info("  samantha-llm memories index")
        return 0

    else:
        print_error(f"Unknown memories subcommand: {subcommand}")
        return 1


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        prog='samantha-llm',
        description='Samantha Hartwell LLM Management Tool',
        add_help=False
    )
    parser.add_argument('command', nargs='?', default='help',
                        choices=['install', 'uninstall', 'status', 'link', 'unlink', 'setup', 'agents', 'start', 'qmd', 'memories', 'help', 'version'],
                        help='Command to execute')
    parser.add_argument('subcommand', nargs='?', default=None,
                        help='Subcommand (for qmd command)')
    parser.add_argument('agent', nargs='?', default=None,
                        help='Agent name (for start command)')
    parser.add_argument('--default', dest='default_agent', metavar='AGENT',
                        help='Set default agent (for setup command)')

    args = parser.parse_args()

    commands = {
        'install': cmd_install,
        'uninstall': cmd_uninstall,
        'status': cmd_status,
        'link': cmd_link,
        'unlink': cmd_unlink,
        'setup': cmd_setup,
        'agents': cmd_agents,
        'start': cmd_start,
        'qmd': cmd_qmd,
        'memories': cmd_memories,
        'help': cmd_help,
        'version': cmd_version,
    }

    return commands[args.command](args)


if __name__ == '__main__':
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        print()
        print_warning("Cancelled by user")
        sys.exit(130)
    except Exception as e:
        print_error(f"Unexpected error: {e}")
        sys.exit(1)
